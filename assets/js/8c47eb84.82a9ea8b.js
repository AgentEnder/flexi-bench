"use strict";(self.webpackChunk_flexi_bench_docs_site=self.webpackChunk_flexi_bench_docs_site||[]).push([[8950],{3338:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var o=t(2540),r=t(3023);const s={id:"different-implementations",title:"Different Implementations",sidebar_label:"Different Implementations",description:"Benchmarking multiple implementations of the same interface using variations and the context API.",hide_title:!0},i="Different Implementations",a={id:"examples/different-implementations",title:"Different Implementations",description:"Benchmarking multiple implementations of the same interface using variations and the context API.",source:"@site/docs/examples/cookbook-different-implementations.md",sourceDirName:"examples",slug:"/examples/different-implementations",permalink:"/flexi-bench/examples/different-implementations",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"different-implementations",title:"Different Implementations",sidebar_label:"Different Implementations",description:"Benchmarking multiple implementations of the same interface using variations and the context API.",hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Full Example",permalink:"/flexi-bench/examples/full-example"},next:{title:"Custom Reporter",permalink:"/flexi-bench/examples/custom-reporter"}},m={},c=[];function l(e){const n={code:"code",h1:"h1",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"different-implementations",children:"Different Implementations"}),"\n",(0,o.jsx)(n.p,{children:"Benchmarking multiple implementations of the same interface using variations and the context API."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="Different Implementations" showLineNumbers',children:"\n/**\n * Cookbook: Same Benchmark, Different Implementations\n *\n * This example demonstrates how to benchmark multiple implementations\n * of the same interface using variations to swap between them.\n *\n * This uses the new context API (withContext/get) to pass implementation\n * references directly, avoiding the environment variable \"dance\".\n */\n\nimport {\n  Benchmark,\n  MarkdownSuiteReporter,\n  Suite,\n  Variation,\n} from '../src/index';\n\n// Define a common interface\ninterface DataProcessor {\n  process(data: number[]): number;\n}\n\n// Implementation 1: Simple loop\nclass LoopProcessor implements DataProcessor {\n  process(data: number[]): number {\n    let sum = 0;\n    for (let i = 0; i < data.length; i++) {\n      sum += data[i];\n    }\n    return sum;\n  }\n}\n\n// Implementation 2: Using reduce\nclass ReduceProcessor implements DataProcessor {\n  process(data: number[]): number {\n    return data.reduce((sum, val) => sum + val, 0);\n  }\n}\n\n// Implementation 3: Using for...of\nclass ForOfProcessor implements DataProcessor {\n  process(data: number[]): number {\n    let sum = 0;\n    for (const val of data) {\n      sum += val;\n    }\n    return sum;\n  }\n}\n\n// Create processor instances\nconst loopProcessor = new LoopProcessor();\nconst reduceProcessor = new ReduceProcessor();\nconst forOfProcessor = new ForOfProcessor();\n\n(async () => {\n  // Generate test data\n  const testData = Array.from({ length: 100000 }, (_, i) => i);\n\n  const results = await new Suite('Data Processing Implementations')\n    .withReporter(\n      new MarkdownSuiteReporter({\n        outputFile: './examples/output/implementation-comparison.results.md',\n        title: 'Implementation Comparison Results',\n        fields: ['min', 'average', 'p95', 'max', 'iterations'],\n      }),\n    )\n    .addBenchmark(\n      new Benchmark('Sum Large Array')\n        .withIterations(10)\n        // Use FromContext factory for clean, concise variation creation\n        // No more environment variable dance!\n        .withVariations(\n          Variation.FromContexts<DataProcessor>('processor', [\n            ['loop', loopProcessor],\n            ['reduce', reduceProcessor],\n            ['forof', forOfProcessor],\n          ]),\n        )\n        .withAction((variation) => {\n          // Access the implementation directly via get()\n          const processor = variation.get<DataProcessor>('processor');\n          if (!processor) {\n            throw new Error('Processor not found in variation context');\n          }\n\n          // Run the benchmark\n          processor.process(testData);\n        }),\n    )\n    .run();\n\n  // Results will be saved to: ./examples/output/implementation-comparison.results.md\n  //\n  // Key takeaways:\n  // - Use Variation.FromContexts() for clean, declarative variation setup\n  // - Pass objects directly - no environment variables needed!\n  // - Use get<T>() to retrieve context data in actions\n  // - Type-safe and concise API\n})();\n\n"})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},3023:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(3696);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);